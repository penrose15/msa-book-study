# 4장 - 마이크로서비스 통신 방식

## 1. 프로세스 내부에서 프로세스 사이로

- 프로세스 내부에서의 통신과 프로세스 간의 통신은 매우 다르다.

### 1.1 성능

- 프로세스  간 호출의 경우 패킷을 전송해야 하므로 그만큼 오버헤드가 걸린다.
- 데이터 전송시 직렬화를 시켜야 하므로 페이로드 크기에 신경을 써야 한다.

### 1.2 인터페이스 변경

- 마이크로서비스 인터페이스에 하위 호환성을 깨뜨리는 변경을 하면 둘다 새 인터페이스를 사용하도록 업데이트를 해야 하기 위해 소비자와 함께 락스텝 배포를 하거나 새로운 마이크로서비스 계약의 출시를 단계적으로 수행할 방법을 찾아야 한다.

### 1.3 에러 처리

- 분산 시스템에서의 에러난 프로세스 내부에서의 에러보다 에러의 특성이 다양해진다.
- [ Distributed Systems ] 책에서 프로세스간 통신에 나타나는 다섯가지 유형의 실패 모드를 분류해놓았다.
    - 충돌 실패(crash failure) : 시스템 작동 능력이 갑작스럽고 완전히 중단되어 시스템이 응답하지 않고 의도된 작업을 수행할 수 없게 되는 것. 정상적으로 되돌리기 위해 일반적으로 재부팅을 한다.
    - 누락 실패 : 전송 후 응답을 받지 못한 상황, 또는 다운스트림 마이크로서비스가 메시지를 발행할 것으로 예상했으나 그냥 중지한 상황
    - 타이밍 실패 : 어떤 일이 너무 일찍 발생하거나 너무 늦게 발생
    - 응답 실패 : 응답은 받았으나, 잘못된 응답인 경우
    - 임의 실패 : 비잔티움 실패, 무언가 잘못되었으나 참여자가 실패가 발생한 사실에 동의하지 못하는 경우
- 여러 에러에 대해 클라이언트가 적절한 조치를 취할 수 있도록 더 풍부한 의미 체계를 갖추는 것이 중요하다.

## 3. 마이크로서비스 통신 방식

**동기식 블로킹** 

마이크로서비스는 다른 마이크로서비스를 호출하고 응답을 기다리는 작업을 차단한다. 

**비동기식 논블로킹**

호출을 보낸 마이크로서비스는 호출 수신여부에 관계없이 처리를 계속할 수 있다. 

**요청 및 응답** 

마이크로서비스는 작업을 수행하도록 다른 마이크로서비스에 요청을 보낸다. 결과를 알려주는 응답을 받을 것을 기대한다. 

**이벤트 기반**

마이크로서비스는 다른 마이크로서비스가 소비하고 반응하는 이벤트를 발산한다. 이벤트를 발행하는 마이크로서비스는 자신이 발행하는 이벤트를 소비하는 마이크로서비스가 어떤 마이크로 서비스인지 알지 못한다. 

**공통 데이터**

일부 공유 데이터 소스를 통해 협업

## 4. 동기식 블로킹

마이크로 서비스가 일종의 호출을 다운스트림 프로세스에 보내고, 호출이 완료될 때까지 기다린다. 

### 장점

친숙하다. (대부분 기본적으로 동기방식으로 동작해왔기 떄문)

### 단점

호출 발신자가 블로킹 되어 있고, 다운 스트림 마이크로서비스의 응답을 기다리고 있을 때 다운스트림에서 응답이 지연되는 경우 호출 발신자는 오랜 시간동안 블로킹이 된다. 

이로 인해 연쇄적인 호출에 더 취약해진다.

### 적용 대상

간단한 마이크로서비스에서는 동기식 블로킹이 문제가 되지 않으나, 호출 체인이 많아질수록 문제가 발생한다. 

- ex ) 주문 처리기 → 결제 → 이상거래 탐지 → 고객 으로 처리흐름이 진행되는 경우
    - 이 4개의 서비스 중 하나의 네트워크에 문제가 발생하면 전체 작업이 실패하게 된다.
    - 열린 상태를 계속 유지해야 하므로 커넥션이 많으면 시스템에 영향을 줄 수 있다.
        - 위의 경우 이상거래 탐지를 백그라운드로 실행할 수 있도록 실행시키면 문제를 완화할 수 있다.(병렬 처리)

## 5. 비동기식 논블로킹

네트워크를 통해 호출을 보내는 행위가 호출하는 마이크로서비스를 블로킹 하지 않는다. 

→ 응답을 기다리지 않고 다른 처리를 계속할 수 있다. 

비동기식 논블로킹 방식에는 3가지 방식이 있다. 

- 공통 데이터를 통한 통신 : 업스트림 마이크로서비스에서 일부 공통 데이터를 변경하고 이 데이터는 나중에 하나 이상의 마이크로서비스에서 사용된다.
- 요청 및 응답 : 마이크로서비스는 다른 마이크로서비승 작업 요청을 보낸다.
- 이벤트 기반 상호작용 : 마이크로 서비스는 발행한 일에 사실적 진술로 생각될 수 있는 이벤트를 브로드캐스트한다.

### 장점

초기 호출을 수행하는 마이크로 서비스와 호출을 수신하는 마이크로 서비스는 일시적으로 분리된다. 

호출에 의해 트리거되는 기능을 처리할 때 오랜 시간이 걸리는 경우에 유용하다. 

- ex ) 주문 처리가가 패키지를 발송하라는 요청을 창고에게 보내고 주문 처리기는 본인의 할일을 한다. 창고는 해당 패키지를 발송한 다음 (몇시간, 며칠이 걸릴 수 있음) 완료되면 창고 서비스가 콜백을 하여 처리 상황을 알린다.

### 단점

동기식 블로킹보다 복잡하다

### 적용 대상

유형마다 장단점이 있으므로 상황에 따라 어떤 유형을 선택할지 고려해야 한다.

## 6. 공통 데이터를 통한 통신

하나의 마이크로서비스가 데이터를 정의한 위치에 넣고, 다른 마이크로서비스가 그 데이터를 이용할 때 사용된다. 

### 구현

일종의 영구 저장소(파일 시스템)이 필요하며, 다운스트림 마이크로서비스는 새 데이터가 가용하다느 사실을 인식하는 매커니즘이 필요(폴링)

대표적으로 데이터 레이크, 데이터 웨어하우스가 있다. 

구조가 하위호환이 불가능한 방식으로 변경되면 생산자가 업데이트 되어야 한다 

### 장점

- 간단하게 구현이 가능하다.
- 데이터양에 크게 구애받지 않는다.

### 단점

- 다운 스트림 마이크로서비스는 폴링이나 주기적으로 트리거 되는 정기 작업을 통해 처리할 신규 데이터가 있음을 인식한다.
    - → 대기시간이 짧은 상황에서는 유용하지 못하다.
- 공통데이터 저장소가 잠재적으로 결합의 원천이 될 수 있다.

### 적용 대상

- 사용 가능 기술에 제약이 있는 경우 (레거시..?)
- 대용량 데이터를 공유해야 할 때

## 7. 요청 및 응답 통신

### 구현 : 동기 대 비동기

동기식

- 다운스트림 마이크로서비스와 네트워크 커넥션이 생상되며 이 커넥션을 따라 전송된다. 업스트림 마이크로 서비스가 응답할 때까지 대기하는 동안 커넥션은 열린 상태로 유지된다.
- 커넥션이 끊어질 경우 문제가 발생할 수 있다.

비동기식

- 메시지 브로커를 통해 메시지로 전송된다.
    
    ![스크린샷 2025-05-06 오후 4.48.31.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%201eb3fb111be88030a5f9de70cce7a309/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.48.31.png)
    
    - 재고 예약 요청은 메시지 브로커를 통해 메시지로 전송되면 바로 창고로 이동하는 것이 아닌 큐에 전송된다. 창고는 가용한 상태에서 이 큐의 메시지를 사용한다.
    - 재고 예약 작업 수행 완료 후 응답을 큐로 전달한다.
- 요청을 수신하는 마이크로서비스는 응답을 어디로 라우팅하는지 암묵적으로 알고 있어야 한다.
- 큐를 사용하여 처리 대기중인 큐에 여러 요청을 버퍼링할 수 있어 너무 많은 요청에 압도되지 않을 수 있다.

### 적용 대상

추가 처리가 일어나기 전에 요청 결과를 확인해야 하는 상황이나 호출이 되지 않아 재시도와 같은 보상 조치를 수행 가능한 마이크로서비스에 매우 적합하다. 

## 8. 이벤트 기반 통신

마이크로서비스가 다른 마이크로서비스에 작업을 요청하는 대신, 마이크로서비스에 수신 여부가 보장되지 않는 이벤트를 발행한다. 

업스트림 마이크로서비스가 다운스트림 마이크로서비스가 적절히 반응할 것이라는 가정하에 이벤트를 브로드캐스트한다. 

- 이벤트의 수신자가 누구인지 모르기 때문에 결합이 느슨하다.

### 구현

마이크로서비스가 이벤트를 발행하는 방법과 소비자가 해당 이벤트 발생을 알아내는 방법에 대해 고려해야 한다. 

- 메시지 브로커
    - 생산자는 API를 통해 이벤트를 브로커에 발행한다.
    - 브로커는 구독을 처리해 이벤트가 도착하면 소비자가 알림을 받을 수 있도록 한다.
- HTTP
    - 아톰(ATOM)은 리소스 피드를 게시하기 위한 시멘틱을 정의하는 REST호환 명세이다.
    - 고객 서비스가 변경될 때마다 고객 서비스는 피드에 이벤트를 바로 게시할 수 있고 소비자들은 단순히 피드를 폴링하여 변경 사항을 찾는다.
    - 지연 시간이 발생할 수 있으며, 소비자가 자신이 받은 메시지를 추적하고 자체 폴링을 관리해야 한다.
    - 경쟁 소비자 패턴
        - 메시지를 두고 경쟁하기 위해 여러 워커 인스턴스를 사용하는 방법
        - 두명 이상의 워커가 동일한 메시지를 보는 것을 막아야 한다.

### 이벤트에 포함 시켜야 하는 것

- API를 통해 공유해야 하는 모든것을 이벤트에 삽입하는 것이 좋다.

![스크린샷 2025-05-06 오후 5.17.01.png](4%E1%84%8C%E1%85%A1%E1%86%BC%20-%20%E1%84%86%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%90%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%89%E1%85%B5%E1%86%A8%201eb3fb111be88030a5f9de70cce7a309/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-05-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.17.01.png)

많은 정보가 포함된 이벤트를 사용하면 수신 마이크로서비스는 이벤트 원천에 추가 요청을 하지 않아도 된다. 

단, 이벤트 크기를 고려해야 한다. 

### 적용 대상

다른 요소와 느슨한 결합에 중점을 두어야 하는 경우