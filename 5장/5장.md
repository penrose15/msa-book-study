## 1. 이상적인 기술을 찾아서

### 1. 하위 호환성을 쉽게 하라

마이크로서비스로 변경을 할 때 서비스를 소비하는 마이크로서비스와 하위 호환성이 깨지지 않도록 해야 한다.

### 2. 인터페이스를 명시적으로 만들어라

마이크로서비스가 노출하는 기능이 소비자에게 분명해야 한다. (외부에서 작업하는 개발자에게 기능이 분명하게 전달되어야 한다. )

충분한 지원 문서와 명시적인 스키마를 사용하는 것을 추천

### 3. API를 기술 중립적으로 유지하라

마이크로서비스를 구현할 때 사용될 기술스택을 강요하는 통합 기술은 피해라

### 4. 소비자를 위해 서비스를 단순하게 만들라

사용자가 마이크로서비스를 사용하기 쉽게 만들어야 한다.

### 5. 내부 구현 세부 사항을 숨겨라

마이크로서비스 내부에 무언가를 변경하려는 경우, 소비자에게도 변경을 요구하게 될 수 있다. 내부 표현의 상세 정보를 노출하는 것을 피해야 한다.

## 2. 기술 선택

- 원격 프로시저 호출(RPC)

  - 원격 프로세스에서 로컬 메서드를 호출할 수 있는 프레임워크이다.
  - SOAP, gRPC

- REST

- GraphQL

  - 소비자가 여러 하위 마이크로서비스에서 정보를 가져올 수 있는 사용자 지정 쿼리를 정의하고 필요한 결과만 반환하기 위해 사용하는 프로토콜

- 메시지 브로커
  - 큐나 토픽을 통해 비동기 통신을 허용하는 미들웨어

### 1. 원격 프로시저 호출

- 로컬 호출을 통해 어딘가에 있는 원격 서비스를 실행하는 기술을 말한다.
- SOAP, gRPC
- RPC맥락에서 스키마는 인터페이스 정의 언어(IDL)라고 하며, SOAP는 해당 스키마를 웹 서비스 정의 언어(WSDL)로 참조한다.
  - 별도의 스키마를 통해 다양한 기술 스택을 위한 클라이언트 및 서버 스텁을 더 쉽게 생성할 수 있다.
- 일반적으로 RPC 기술을 사용한다는 것은 직렬화 프로토콜에 투자한다는 의미이다.
- RPC프레임워크는 데이터 직렬화/역직렬화되는 방법을 정의한다.
- 명시적 스키마가 있는 RPC 프레임워크를 사용하면 클라이언트 코드를 생성하기 쉬워진다.
  - 하지만 클라이언트 측 코드 생성을 위해 클라이언트는 스키마를 해당 호출 외부에서 가져올 수 있어야 한다.

**문제점**

- 기술 결합 발생
- 로컬 호출은 원격 호출과 같지 않음
  - RPC는 호출의 복잡성을 숨길 수 있으나 과도하게 감춰질 수 있다.
  - 이로 인해 마샬링, 역마샬링 비용이 크게 든다.
- 깨지기 쉽다
  - 서버에 변경사항이 발생하면 클라이언트에도 이를 반영해야 한다.
  - 한쪽이 변경을 하지 않으면 관련된 코드가 깨질 수 있다. (락스텝 릴리스 고려)

**적용 대상**

- 동기식 요청 및 응답 모델, 반응형 확장
- 스펙트럼의 클라이언트 코드를 잘 관리할 수 있는 경우

### 2. REST

- REST와 HTTP

- 애플리케이션 상태 엔진으로서의 하이퍼미디어(HATEOAS)

  - 클라이언트와 서버간의 결합을 피하기 위해 하이퍼미디어를 애플리케이션 상태 엔진으로 볼 수 있다.
  - 하이퍼미디어는 다앙햔 포맷으로 된 다양한 콘텐츠에 대한 링크가 콘텐츠에 포함된 개념이다.
  - 클라이언트가 다른 리소스에 대한 링크를 통해 서버와의 상호작용을 수행할 수 있다.

**문제점**

- HTTP 기반의 REST 애플리케이션 프로토콜을 위한 클라이언트 측 코드를 생성할 수 없다.
  - 문서화가 어렵다
- 성능 이슈
  - HTTP 요청마다 발생하는 오버헤드는 낮은 지연 시간이 필요한 요구 사항에서 문제가 될 수 있다.
    - TCP
    - HTTP/3으로 해결되고 있음

**적용 대상**

- 다양한 클라이언트의 액서스 허용이 필요한 경우

### 3. GraphQL

- 클라이언트 측 장치가 동일한 정보를 검색하기 위해 여러 번 요청할 필요가 없도록 쿼리를 정의할 수 있다.
- GraphQL을 통해 모바일 장치에서 필요한 정보를 모두 가져오는 단일 쿼리를 실행할 수 있다.
  - GraphQL의 엔드 포인트를 클라이언트 장치에 노출하는 마이크로서비스가 필요하다.

**문제점**

- 쿼리 비용이 비싸다(동적으로 변하는 쿼리로 인한 부하)
- 캐싱이 어렵다
  - 쿼리가 구체적인 경우 캐시 적중률 하락
- 읽기 성능이 쓰기보다 떨어진다.
- GraphQL은 데이터로 작업하는 것처럼 느껴져 마이크로서비스가 데이터베이스의 래퍼로 느끼게 만들 수 있다.

**적용 대상**

- 외부 클라이언트에 기능을 노출하는 시스템의 경계에서 사용하는 데 가장 적합하다.

### 4. 메시지 브로커

- 미들웨어라고 하는 중개자로서 프로세스 사이에 위치해 프로세스 간의 통신을 관리한다.

**토픽과 큐**

- 브로커는 큐나 토픽 이 두가지 모두를 제공하는 경우가 많다.
- 발신자는 큐에 메시지를 넣고 소비자는 해당 큐에 메시지를 읽는다.
- 토픽 기반 시스템을 사용하면 여러 소비자가 토픽을 구독하고 구독한 각 소비자는 해당 메시지의 복사본을 받는다.
- 토픽을 통해 여러 소비자 그룹을 가질 수 있다.
- 토픽은 이벤트 기반 협업 방식에 적합하지만, 큐는 요청 및 응답 통신에 더 적합하다.

**전달 보장**

- 브로커는 비동기 통신에 매우 유용하다.
- 브로커가 메시지를 전달할 수 있을 때까지 보관하기 때문에 다운스트림 대상이 가용하지 않더라도 문제가 되지 않는다.
- 브로커는 메시지가 배달될 떄까지 메시지를 보관해야 한다. 이를 위해 브로커는 일종의 클러스터 기반 시스템으로 실행되어 한 머신이 고장 나더라도 메시지가 손실되지 않도록 해야 한다.

**신뢰**

- 브로커를 얼마나 믿을 지 결정해야 한다.

**선택**

- 다양한 메시지 브로커가 존재한다
  - RabbitMQ, ActiveMQ
  - AWS SQS, SNS, Kinesis

**카프카**

- 대규모를 위해 설계된 메시지 브로커
- 메시지 영속성
- 스트림 처리를 기본으로 제공

## 3. 직렬화 포맷

많은 기술들은 네트워크 호출을 위해 데이터를 은닉하는 여러 방법을 제공한다.

1. 텍스트 포맷

   - 표준 텍스트 포맷을 사용하면 클라이언트가 자원을 사용하는 방법이 훨씬 유연해진다.
   - JSON

2. 바이너리 포맷

   - 낮은 지연 시간이 필요한 경우 유용하다

## 4. 스키마

- 엔드 포인트가 노출되고 수용하는 것을 정의하기 위해 스키마를 사용할지 현재 논의가 되고 있다.
- 스키마는 다양한 타입이 가능하고, 직렬화 포맷을 선택하면 일반적을 사용 가능한 스키마 기술을 정의하게 된다.

### 1. 구조적 계약 위반 대 의미적 계약 위반

**구조적 계약 위반**

- 소비자가 더 이상 호환되지 않는 방식으로 엔드포인트의 구조가 변경되는 상황
  - 필드나 메서드가 제거되거나 새로운 필드가 추가되는 경우

**의미적 계약 위반**

- 구조는 동일하나 소비자의 기대와 다른 방식으로 행동 양식이 변경되는 상황

### 2. 스키마를 사용해야 할까?

- 스키마를 사용하고 다른 버전의 스키마를 비교하면 구조적 위반을 포착할 수 있다.
- 의미적/구조적 파손 포착을 하려면 테스트를 진행해야 한다
- 진짜 문제는 스키마의 실제 존재 여부가 아닌 해당 스키마가 명시적인지의 여부이다.
  - 마이크로서비스가 무엇을 노출해야 하는지에 대해 명시적이어야 한다.

## 5. 마이크로서비스 간의 변경 처리

## 6. 중단 변경 피하기

- 확장 변경 : 마이크로서비스 인터페이스에 새로운 것을 추가하라. 단, 오래된 것은 제거하지 않아야 한다.
- 관대한 독자 : 마이크로서비스 인터페이스를 사용할 때 기대하는 것에 유연해야 한다.
- 올바른 기술 : 인터페이스에 하위 호환 가능한 변경 사항을 쉽게 적용하는 기술을 선택하라
- 명시적 인터페이스 : 마이크로서비스가 노출하는 내용은 명확해야 한다. 이를 통해 클라이언트는 작업을 더 쉽게 수행하고, 마이크로서비스 유지보수자는 자유룝게 변경이 가능해진다.
- 우발적 중단 변경 일찍 발견하기 : 변경사항이 배포되기 전, 운영 환경에서 소비자를 중단시킬만한 변경 사항을 찾아내는 매커니즘이 있어야 한다.
